{"/io_operations/":{"data":{"":"","#":"I/O operations and serialization format examples Arguments : Test that args can be passed to script\nDecode : Test that base64 can be decoded as a string\nEncode : Test that a string can be encoded as base64\nJSON Array : Test that JSON array is parsed correctly\nJSON Control Chars : Test that control characters and emojis are output in valid JSON\nJSON Numbers : Test that JSON list of numbers is parsed correctly\nJSON Object Array : Test that a JSON array made of objects is parsed correctly\nJSON Object With Array Values : Test that a JSON object with arrays as values is parsed correctly\nJSON Stdout Object : Test that JSON object is parsed correctly\nNull Char : Test outputing a null character\nRead File : Check that a file is read line by line, when file path is given as command line argument\nRead JSON File : Test that a JSON file is read correctly\nStdin : Check that input is read from stdin, line by line.\nStreaming Pipe In and Out : Test that named pipe can be read line by line and can write to output pipe without waiting for all lines to arrive.\nStreaming Pipe In : Test that named pipe can be read line by line and can write to stdout\nStreaming Stdin : Test that streaming stdin can be read line by line and can write to stdout without waiting for all lines to arrive\nWrite File : Test that a script, given a path to a named pipe, can write to that named pipe"},"title":"I/O Operations"},"/io_operations/arguments/":{"data":{"arguments#arguments":"argumentsTest that args can be passed to script","bash-3#Bash 3":"arguments.sh\n#!/bin/bash # Script to read an argument and print as lowercase in stdout file_path=\"$1\" if [ -z \"$file_path\" ]; then echo \"Usage: $0 \u003cfile_path\u003e\" exit 1 fi tr '[:upper:]' '[:lower:]' \u003c\u003c\u003c \"$file_path\" ","bash-5#Bash 5":"arguments.sh\n#!/bin/bash # Script to read an argument and print as lowercase in stdout file_path=\"$1\" if [ -z \"$file_path\" ]; then echo \"Usage: $0 \u003cfile_path\u003e\" exit 1 fi echo \"${file_path,,}\" ","c#C#":"Arguments.cs\nclass Arguments { public static void Main(string[] args) { Console.WriteLine(args[0].ToLower()); } } ","deno#Deno":"arguments.mjs\n// Script to read command line argument and write to stdout console.log(Deno.args[0].toLowerCase()) ","go#Go":"arguments.go\n// Script to read an argument and print as lowercase in stdout package main import ( \"fmt\" \"os\" \"strings\" ) func main() { fmt.Println(strings.ToLower(os.Args[1])) } ","java#Java":"Arguments.java\n// Script to read an argument and print as lowercase in stdout class Main{ public static void main(String[] args){ String user = args[0]; System.out.println(user.toLowerCase()); } } ","lua#Lua":"arguments.lua\n--Script to read an argument and print as lowercase in stdout print(arg[1]:lower()) ","nodejs#Nodejs":"arguments.mjs\n// Script to read command line argument and write to stdout console.log(process.argv[2].toLowerCase()) ","perl#Perl":"arguments.pl\n# Script to read an argument and print as lowercase in stdout use strict; use warnings; print lc($ARGV[0]), \"\\n\"; ","php#Php":"arguments.php\n\u003c?php // Read command line arguments and write to stdout echo strtolower($argv[1]) . \"\\n\"; ","python#Python":"arguments.py\n\"\"\"Script reads command line arguments and writes to stdout\"\"\" import sys print(sys.argv[1].lower()) ","r#R":"arguments.R\n#' Script reads command line arguments and writes to stdout in lowercase cat(tolower(commandArgs(trailingOnly = TRUE)), fill = TRUE) ","raku#Raku":"arguments.raku\n# Script to read an argument and print as lowercase in stdout use v6; my $arg = @*ARGS[0]; say $arg.lc; ","ruby#Ruby":"arguments.rb\n# Script to read an argument and print as lowercase in stdout puts ARGV[0].downcase ","rust#Rust":"arguments.rs\n// Script to read an argument and print as lowercase in stdout use std::env; fn main() { let user = env::args().nth(1).expect(\"Expected one argument\"); println!(\"{}\", user.to_lowercase()); } ","swift#Swift":"arguments.swift\n#!/usr/bin/swift import Foundation let args = CommandLine.arguments guard args.count \u003e 1 else { print(\"Usage: \\(args[0]) \u003cargument\u003e\"); exit(1) } print(args[1].lowercased()) "},"title":"arguments"},"/io_operations/decode/":{"data":{"bash-3#Bash 3":"decode.sh\n#!/bin/bash # Script to decode Base64 text encoded_string=\"$1\" if [ -z \"$encoded_string\" ]; then echo \"Usage: $0 \u003cencoded_string\u003e\" exit 1 fi base64 -d \u003c\u003c\u003c \"$encoded_string\" echo # tests expect a newline at the end ","bash-5#Bash 5":"decode.sh\n#!/bin/bash # Script to decode Base64 text encoded_string=\"$1\" if [ -z \"$encoded_string\" ]; then echo \"Usage: $0 \u003cencoded_string\u003e\" exit 1 fi base64 -d \u003c\u003c\u003c \"$encoded_string\" echo # tests expect a newline at the end ","c#C#":"Decode.cs\n//Script to decode Base64 text using System; class Decode{ public static void Main(string[] args){ string encodedString = args[0]; byte[] decodedBytes = Convert.FromBase64String(encodedString); string decodedString = System.Text.Encoding.UTF8.GetString(decodedBytes); Console.WriteLine(decodedString); } } ","decode#decode":"decodeTest that base64 can be decoded as a string","deno#Deno":"decode.mjs\n// Script to decode Base64 text const encodedString = Deno.args[0] // Get the Base64-encoded string from command-line arguments const decodedString = atob(encodedString) console.log(decodedString) ","go#Go":"decode.go\n// Script to decode Base64 text package main import ( \"encoding/base64\" \"fmt\" \"os\" ) func main() { decodedBytes, _ := base64.StdEncoding.DecodeString(os.Args[1]) fmt.Println(string(decodedBytes)) } ","java#Java":"Decode.java\n//Script to decode Base64 text import java.util.Base64; public class Decode { public static void main(String[] args) { if (args.length == 0) { System.out.println(\"Usage: java Decode.java \u003cencoded_string\u003e\"); System.exit(1); } String encodedString = args[0]; byte[] decodedBytes = Base64.getDecoder().decode(encodedString); String decodedString = new String(decodedBytes); System.out.println(decodedString); } } ","lua#Lua":"decode.lua\n-- Lua script to decode Base64 encoded string from command-line argument local base64 = require(\"base64\") print(base64.decode(arg[1])) ","nodejs#Nodejs":"decode.mjs\n// Script to decode Base64 text const encodedString = process.argv[2] // Get the Base64-encoded string from command-line arguments const decodedString = atob(encodedString) console.log(decodedString) ","perl#Perl":"decode.pl\nuse strict; use warnings; use MIME::Base64; print decode_base64($ARGV[0]), \"\\n\"; ","php#Php":"decode.php\n\u003c?php // Script to decode Base64 text $encodedString = $argv[1]; // Decode the Base64 encoded string $decodedString = base64_decode($encodedString); echo $decodedString . \"\\n\"; ","python#Python":"decode.py\n\"\"\"Script to decode Base64 text\"\"\" import base64 import sys encoded_string = sys.argv[1] decoded_string = base64.b64decode(encoded_string).decode() print(decoded_string) ","r#R":"decode.R\n#' Script to decode Base64 text library(base64enc) # Get the command-line arguments (strings) args \u003c- commandArgs(trailingOnly = TRUE) # Decode from base64 to raw bytes then convert raw bytes to string decoded_string \u003c- rawToChar(base64decode(args)) cat(decoded_string, fill = TRUE) ","raku#Raku":"decode.raku\nuse v6; use MIME::Base64; say MIME::Base64.decode-str(@*ARGS[0]); ","ruby#Ruby":"decode.rb\n# Script to decode Base64 text # Note that Base64.decode64 ignores characters outside the base alphabet # see Ruby docs: https://ruby-doc.org/3.0.6/stdlibs/base64/Base64.html require 'base64' encoded_string = ARGV[0] decoded_string = Base64.decode64(encoded_string) puts decoded_string ","rust#Rust":"decode.rs\n//cargo-deps: base64=\"0.13\" //Script to decode Base64 text extern crate base64; use base64::decode; use std::env; fn main() { let encoded_string = env::args().nth(1).expect(\"Expected one argument\"); let decoded_bytes = decode(encoded_string).unwrap(); let decoded_string = String::from_utf8(decoded_bytes).unwrap(); println!(\"{}\", decoded_string); } ","swift#Swift":"decode.swift\n#!/usr/bin/swift import Foundation guard CommandLine.arguments.count \u003e 1 else { print(\"Usage: \\(CommandLine.arguments[0]) \u003cencoded_string\u003e\") exit(1) } let encodedString = CommandLine.arguments[1] let data = Data(base64Encoded: encodedString) print(String(data: data!, encoding: .utf8)!) "},"title":"decode"},"/io_operations/encode/":{"data":{"bash-3#Bash 3":"encode.sh\n#!/bin/bash # Script to encode a string as Base64 test_string=\"$1\" if [ -z \"$test_string\" ]; then echo \"Usage: $0 \u003ctest_string\u003e\" exit 1 fi echo -n \"$test_string\" | base64 ","bash-5#Bash 5":"encode.sh\n#!/bin/bash # Script to encode a string as Base64 test_string=\"$1\" if [ -z \"$test_string\" ]; then echo \"Usage: $0 \u003ctest_string\u003e\" exit 1 fi echo -n \"$test_string\" | base64 ","c#C#":"Encode.cs\n//Script to encode a string as Base64 using System; class Encode{ public static void Main(string[] args){ string testString = args[0]; string encodedString = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(testString)); Console.WriteLine(encodedString); } } ","deno#Deno":"encode.mjs\n// Script to encode a string as Base64 const testString = Deno.args[0] // Get the Base64-encoded string from command-line arguments const encodedString = btoa(testString) console.log(encodedString) ","encode#encode":"encodeTest that a string can be encoded as base64","go#Go":"encode.go\n//Script to encode a string as Base64 package main import ( \"encoding/base64\" \"fmt\" \"os\" ) func main() { fmt.Println(base64.StdEncoding.EncodeToString([]byte(os.Args[1]))) } ","java#Java":"Encode.java\n//Script to encode a string as Base64 import java.util.Base64; public class Encode { public static void main(String[] args) { if (args.length == 0) { System.out.println(\"Usage: java Encode.java \u003ctest_string\u003e\"); System.exit(1); } String testString = args[0]; String encodedString = Base64.getEncoder().encodeToString(testString.getBytes()); // Print the encoded string System.out.println(encodedString); } } ","lua#Lua":"encode.lua\n-- Lua script to encode a string as Base64 local base64 = require(\"base64\") print(base64.encode(arg[1])) ","nodejs#Nodejs":"encode.mjs\n// Script to encode a string as Base64 const testString = process.argv[2] // Get the Base64-encoded string from command-line arguments const encodedString = btoa(testString) console.log(encodedString) ","perl#Perl":"encode.pl\nuse strict; use warnings; use MIME::Base64; print encode_base64($ARGV[0], ''), \"\\n\"; ","php#Php":"encode.php\n\u003c?php // Script to encode a string as Base64 $stringToEncode = $argv[1]; // Encode the string as Base64 $encodedString = base64_encode($stringToEncode); echo $encodedString . \"\\n\"; ","python#Python":"encode.py\n\"\"\"Script to encode a string as Base64\"\"\" import base64 import sys test_string = sys.argv[1] # Encode string argument as bytes, encode as base64 then decode as string encoded_string = base64.b64encode(test_string.encode()).decode() # Print as a string, not bytes print(encoded_string) ","r#R":"encode.R\n#' Script to encode text as Base64 library(base64enc) # Get the command-line arguments (strings) args \u003c- commandArgs(trailingOnly = TRUE) # Convert string to raw bytes then encode as base64 encoded_string \u003c- base64encode(charToRaw(args)) cat(encoded_string, fill = TRUE) ","raku#Raku":"encode.raku\nuse v6; use MIME::Base64; say MIME::Base64.encode-str(@*ARGS[0]); ","ruby#Ruby":"encode.rb\n# Script to encode a string as Base64 # Note that Line feeds are added to every 60 encoded characters require 'base64' test_string = ARGV[0] # Encode string argument as string encoded_string = Base64.encode64(test_string) puts encoded_string ","rust#Rust":"encode.rs\n//cargo-deps: base64=\"0.13\" use std::env; extern crate base64; fn main() { let test_string = env::args().nth(1).expect(\"Expected one argument\"); let encoded_string = base64::encode(test_string); println!(\"{}\", encoded_string); } ","swift#Swift":"encode.swift\n#!/usr/bin/swift //Script to encode a string as Base64 import Foundation guard CommandLine.arguments.count == 2 else { print(\"Usage: swift script.swift \u003ctest_string\u003e\") exit(1) } let data = CommandLine.arguments[1].data(using: .utf8)! print(data.base64EncodedString()) "},"title":"encode"},"/io_operations/json_array/":{"data":{"c#C#":"JsonArray.cs\n//Script takes args and turns into JSON array using System; using System.Text.Json; class JsonArray{ public static void Main(string[] args){ string[] inputArray = args; string jsonString = JsonSerializer.Serialize(inputArray); Console.WriteLine(jsonString); } } ","deno#Deno":"json_array.mjs\n// Script takes args and turns into JSON array const myStrings = Deno.args // Get command-line arguments, excluding 'node' and script name console.log(JSON.stringify(myStrings)) ","go#Go":"json_array.go\n//Script takes args and turns into JSON array package main import ( \"encoding/json\" \"fmt\" \"os\" ) func main() { args := os.Args[1:] var jsonArray []string for _, arg := range args { jsonArray = append(jsonArray, arg) } jsonArrayBytes, _ := json.Marshal(jsonArray) fmt.Println(string(jsonArrayBytes)) } ","java#Java":"JsonArray.java\n//Script takes args and turns into JSON array import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ArrayNode; public class JsonArray { public static void main(String[] args) { if (args.length == 0) { System.out.println(\"Usage: java JsonArray \u003cstring1\u003e \u003cstring2\u003e ...\"); System.exit(1); } ObjectMapper objectMapper = new ObjectMapper(); ArrayNode arrayNode = objectMapper.createArrayNode(); for (String arg : args) { arrayNode.add(arg); } String jsonArrayString = arrayNode.toString(); System.out.println(jsonArrayString); } } ","json_array#json_array":"json_arrayTest that JSON array is parsed correctly","lua#Lua":"json_array.lua\n-- Lua script to convert command-line arguments to JSON array local cjson = require(\"dkjson\") local args = {} for i = 1, #arg do table.insert(args, arg[i]) end print(cjson.encode(args)) ","nodejs#Nodejs":"json_array.mjs\n// Script takes args and turns into JSON array const myStrings = process.argv.slice(2) // Get command-line arguments, excluding 'node' and script name console.log(JSON.stringify(myStrings)) ","perl#Perl":"json_array.pl\n# Script takes args and turns into JSON array use strict; use warnings; use JSON; print encode_json(\\@ARGV), \"\\n\"; ","php#Php":"json_array.php\n\u003c?php // Script takes args and turns into JSON array // Get the command-line arguments into an array $myStrings = array_slice($argv, 1); // Encode the array as JSON and print to stdout echo json_encode($myStrings) . \"\\n\"; ","python#Python":"json_array.py\n\"\"\"Script takes args and turns into JSON array\"\"\" import json import sys my_strings = sys.argv[1:] # Cast to JSON and print to stdout print(json.dumps(my_strings)) ","r#R":"json_array.R\n#' Script takes command line arguments and turns into JSON array library(jsonlite) # Get the command-line arguments (strings) args \u003c- commandArgs(trailingOnly = TRUE) # Convert the strings to a JSON array and print to stdout cat(toJSON(args)) ","raku#Raku":"json_array.raku\n# Script takes args and turns into JSON array use v6; use JSON::Fast; say to-json(@*ARGS); ","ruby#Ruby":"json_array.rb\n# Script takes args and turns into JSON array require 'json' my_strings = ARGV puts JSON.generate(my_strings) ","rust#Rust":"json_array.rs\n//cargo-deps: json=\"0.12.4\" use json::JsonValue; use std::env; extern crate json; fn main() { let substrings: Vec\u003cString\u003e = env::args().skip(1).collect(); let json_array: JsonValue = substrings.into(); println!(\"{}\", json_array.dump()); } ","swift#Swift":"json_array.swift\n//Script takes args and turns into JSON array import Foundation guard CommandLine.arguments.count \u003e 1 else { print(\"Usage: swift script.swift \u003carg1\u003e [\u003carg2\u003e ...]\") exit(1) } let myStrings = Array(CommandLine.arguments.dropFirst()) let jsonData = try JSONSerialization.data(withJSONObject: myStrings) print(String(data: jsonData, encoding: .utf8)!) "},"title":"json_array"},"/io_operations/json_control_chars/":{"data":{"c#C#":"JsonControlChars.cs\n//Script takes control characters and outputs valid JSON using System; using System.Text.Json; class JsonControlChars{ public static void Main(string[] args){ string testString = args[0]; string jsonString = JsonSerializer.Serialize(testString); Console.WriteLine(jsonString); } } ","deno#Deno":"json_control_chars.mjs\n// Script takes control characters and outputs valid JSON const myString = Deno.args[0] console.log(JSON.stringify(myString)) ","go#Go":"json_control_chars.go\n// Script takes control characters and outputs valid JSON package main import ( \"encoding/json\" \"fmt\" \"os\" ) func main() { testString := os.Args[1] jsonString, _ := json.Marshal(testString) fmt.Println(string(jsonString)) } ","java#Java":"JsonControlChars.java\n//Script takes control characters and outputs valid JSON import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; public class JsonControlChars { public static void main(String[] args) throws JsonProcessingException{ if (args.length == 0) { System.out.println(\"Usage: java JsonControlChars \u003ctest_string\u003e\"); System.exit(1); } String testString = args[0]; ObjectMapper objectMapper = new ObjectMapper(); // Convert testString to JSON string String jsonString = objectMapper.writeValueAsString(testString); System.out.println(jsonString); } } ","json_control_chars#json_control_chars":"json_control_charsTest that control characters and emojis are output in valid JSON note: control character “\\0” is used by C (and Python) to end strings and so we can’t pass it as argument in the test string because it will raise “invalid argument” error","lua#Lua":"json_control_chars.lua\n-- Lua script to output valid JSON from a string argument local cjson = require(\"dkjson\") print(cjson.encode(arg[1])) ","nodejs#Nodejs":"json_control_chars.mjs\n// Script takes control characters and outputs valid JSON const myString = process.argv[2] console.log(JSON.stringify(myString)) ","perl#Perl":"json_control_chars.pl\n# Script takes control characters and outputs valid JSON use strict; use warnings; use JSON; print JSON-\u003enew-\u003eencode($ARGV[0]); ","php#Php":"json_control_chars.php\n\u003c?php // Script takes control characters and outputs valid JSON // Get the command-line argument $testString = $argv[1]; // Cast the string to JSON and print to stdout echo json_encode($testString) . \"\\n\"; ","python#Python":"json_control_chars.py\n\"\"\"Script takes control characters and outputs valid JSON\"\"\" import json import sys test_string = sys.argv[1] # Cast to JSON and print to stdout print(json.dumps(test_string)) ","r#R":"json_control_chars.R\n#' Script takes control characters and emoji and outputs valid JSON library(jsonlite) # Get the command-line arguments (strings) args \u003c- commandArgs(trailingOnly = TRUE) cat(toJSON(args, auto_unbox = TRUE)) ","raku#Raku":"json_control_chars.raku\n# Script takes control characters and outputs valid JSON use v6; use JSON::Fast; say to-json(@*ARGS[0]); ","ruby#Ruby":"json_control_chars.rb\n# Script takes control characters and outputs valid JSON require 'json' test_string = ARGV[0] # Cast to JSON and print to stdout puts JSON.generate(test_string) ","rust#Rust":"json_control_chars.rs\n//cargo-deps: json=\"0.12.4\" //Script takes control characters and outputs valid JSON use json::JsonValue; use std::env; extern crate json; fn main() { let test_string = env::args().nth(1).expect(\"Expected one argument\"); let json_value: JsonValue = test_string.into(); println!(\"{}\", json_value.dump()); } ","swift#Swift":"json_control_chars.swift\n//Script takes control characters and outputs valid JSON import Foundation guard CommandLine.arguments.count == 2 else { print(\"Usage: swift JsonControlChars.swift \u003ctest_string\u003e\") exit(1) } let testString = CommandLine.arguments[1] let jsonData = try JSONEncoder().encode(testString) print(String(data: jsonData, encoding: .utf8)!) "},"title":"json_control_chars"},"/io_operations/json_numbers/":{"data":{"c#C#":"JsonNumbers.cs\n// Script takes string arguments and outputs a JSON array of numbers representing // the length of each argument using System; using System.Collections.Generic; using System.Text; using System.Text.Json; class JsonNumbers { public static void Main(string[] args) { var numbers = args.Select(arg =\u003e arg.Length).ToArray(); string jsonArrayString = JsonSerializer.Serialize(numbers); Console.WriteLine(jsonArrayString); } } ","deno#Deno":"json_numbers.mjs\n// Script takes args and outputs a list of lengths const myStrings = Deno.args // Create an array of numbers based on the length of the string args const stringLengths = myStrings.map((string) =\u003e string.length) const jsonString = JSON.stringify(stringLengths) console.log(jsonString) ","go#Go":"json_numbers.go\n// Script takes string arguments and outputs a JSON array of numbers representing // the length of each argument package main import ( \"encoding/json\" \"fmt\" \"os\" ) func main() { args := os.Args[1:] var lengths []int for _, arg := range args { lengths = append(lengths, len(arg)) } jsonArrayBytes, _ := json.Marshal(lengths) fmt.Println(string(jsonArrayBytes)) } ","java#Java":"JsonNumbers.java\n// Script takes string arguments and outputs a JSON array of numbers representing // the length of each argument import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ArrayNode; public class JsonNumbers { public static void main(String[] args) throws Exception{ if (args.length == 0) { System.out.println(\"Usage: java JsonNumbers \u003cstring1\u003e \u003cstring2\u003e ...\"); System.exit(1); } ObjectMapper objectMapper = new ObjectMapper(); ArrayNode arrayNode = objectMapper.createArrayNode(); for (String str : args) { arrayNode.add(str.length()); } String jsonArrayString = objectMapper.writeValueAsString(arrayNode); System.out.println(jsonArrayString); } } ","json_numbers#json_numbers":"json_numbersTest that JSON list of numbers is parsed correctly","lua#Lua":"json_numbers.lua\n-- Lua script to calculate lengths of string arguments and output JSON array local cjson = require(\"dkjson\") local lengths = {} for i = 1, #arg do table.insert(lengths, string.len(arg[i])) end print(cjson.encode(lengths)) ","nodejs#Nodejs":"json_numbers.mjs\n// Script takes args and outputs a list of lengths const myStrings = process.argv.slice(2) // Create an array of numbers based on the length of the string args const stringLengths = myStrings.map((string) =\u003e string.length) const jsonString = JSON.stringify(stringLengths) console.log(jsonString) ","perl#Perl":"json_numbers.pl\n# Script takes string arguments and outputs a JSON array of numbers representing # the length of each argument use strict; use warnings; use JSON; print encode_json([map { length } @ARGV]); ","php#Php":"json_numbers.php\n\u003c?php // Script takes args and outputs a list of lengths // Get the command-line arguments into an array $myStrings = array_slice($argv, 1); // Create an array of numbers based on the length of the string args $stringLengths = array_map('strlen', $myStrings); // Encode the array as JSON and print to stdout echo json_encode($stringLengths) . \"\\n\"; ","python#Python":"json_numbers.py\n\"\"\"Script takes args and outputs a list of lengths\"\"\" import json import sys my_strings = sys.argv[1:] # Create an array of numbers based on the length of the string args string_lengths = [len(string) for string in my_strings] # Cast to JSON and print to stdout print(json.dumps(string_lengths)) ","r#R":"json_numbers.R\n#' Script takes command-line arguments and outputs a JSON array library(jsonlite) # Get the command-line arguments (strings) args \u003c- commandArgs(trailingOnly = TRUE) # Calculate the lengths of the strings and store them in an array string_lengths \u003c- sapply(args, nchar) # Convert the array of string lengths to a JSON array and print to stdout cat(toJSON(string_lengths)) ","raku#Raku":"json_numbers.raku\n# Script takes string arguments and outputs a JSON array of numbers representing the length of each argument use v6; use JSON::Fast; say to-json(@*ARGS.map(*.chars)); ","ruby#Ruby":"json_numbers.rb\n# Script takes string arguments and outputs a JSON array of numbers representing # the length of each argument require 'json' my_strings = ARGV string_lengths = my_strings.map(\u0026:length) puts JSON.generate(string_lengths) ","rust#Rust":"json_numbers.rs\n//cargo-deps: json=\"0.12.4\" // Script takes string arguments and outputs a JSON array of numbers representing // the length of each argument use json::JsonValue; use std::env; extern crate json; fn main() { let args = env::args().skip(1); let json_array: JsonValue = args .map(|arg| arg.len().into()) .collect::\u003cVec\u003cJsonValue\u003e\u003e() .into(); println!(\"{}\", json_array.dump()); } ","swift#Swift":"json_numbers.swift\n//Script takes args and outputs a list of lengths import Foundation guard CommandLine.arguments.count \u003e 1 else { print(\"Usage: swift script.swift \u003carg1\u003e [\u003carg2\u003e ...]\") exit(1) } let myStrings = CommandLine.arguments.dropFirst() let stringLengths = myStrings.map { $0.count } let jsonData = try JSONSerialization.data(withJSONObject: stringLengths) print(String(data: jsonData, encoding: .utf8)!) "},"title":"json_numbers"},"/io_operations/json_object_array/":{"data":{"c#C#":"JsonObjectArray.cs\n// Script outputs arrays of objects as JSON using System; using System.Collections.Generic; using System.Text; using System.Text.Json; class JsonObjectArray { public static void Main(string[] args){ var jsonObjects = args.Select(str =\u003e new Dictionary\u003cstring, object\u003e { { str.ToUpper(), str.Length } }).ToList(); string jsonArrayString = JsonSerializer.Serialize(jsonObjects); Console.WriteLine(jsonArrayString); } } ","deno#Deno":"json_object_array.mjs\n// Script writes an array of objects to stdout const args = Deno.args // Make a list of dictionaries from the given args, one dict per arg const myArray = args.map((arg) =\u003e ({ [arg.toUpperCase()]: arg.length })) console.log(JSON.stringify(myArray)) ","go#Go":"json_object_array.go\n// Script outputs arrays of objects as JSON package main import ( \"encoding/json\" \"fmt\" \"os\" \"strings\" ) func main() { args := os.Args[1:] var arrayNode []map[string]interface{} for _, str := range args { obj := make(map[string]interface{}) obj[strings.ToUpper(str)] = len(str) arrayNode = append(arrayNode, obj) } jsonArrayBytes, _ := json.Marshal(arrayNode) fmt.Println(string(jsonArrayBytes)) } ","java#Java":"JsonObjectArray.java\n// Script outputs arrays of objects as JSON import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; public class JsonObjectArray { public static void main(String[] args) throws Exception{ if (args.length == 0) { System.out.println(\"Usage: java JsonObjectArray \u003cstring1\u003e \u003cstring2\u003e ...\"); System.exit(1); } ObjectMapper objectMapper = new ObjectMapper(); ArrayNode arrayNode = objectMapper.createArrayNode(); for (String string : args) { ObjectNode obj = objectMapper.createObjectNode(); obj.put(string.toUpperCase(), string.length()); arrayNode.add(obj); } String jsonArrayString = objectMapper.writeValueAsString(arrayNode); System.out.println(jsonArrayString); } } ","json_object_array#json_object_array":"json_object_arrayTest that a JSON array made of objects is parsed correctly","lua#Lua":"json_object_array.lua\n-- Lua script to transform string arguments into an array of dictionaries and output as JSON local cjson = require(\"dkjson\") local my_array = {} for i = 1, #arg do local string = arg[i] table.insert(my_array, { [arg[i]:upper()] = arg[i]:len() }) end print(cjson.encode(my_array)) ","nodejs#Nodejs":"json_object_array.mjs\n// Script writes an array of objects to stdout const args = process.argv.slice(2) // Make a list of dictionaries from the given args, one dict per arg const myArray = args.map((arg) =\u003e ({ [arg.toUpperCase()]: arg.length })) console.log(JSON.stringify(myArray)) ","perl#Perl":"json_object_array.pl\n# Script outputs arrays of objects as JSON use strict; use warnings; use JSON; print JSON-\u003enew -\u003ecanonical(1) -\u003eencode([map { { uc($_) =\u003e length($_) } } @ARGV]); ","php#Php":"json_object_array.php\n\u003c?php // Script writes an array of objects to stdout // Get the command-line arguments into an array $args = array_slice($argv, 1); // Create an array of dictionaries (associative arrays), one per argument $myArray = array_map(function($arg) { return [strtoupper($arg) =\u003e strlen($arg)]; }, $args); // Encode the array as JSON and print to stdout echo json_encode($myArray) . \"\\n\"; ","python#Python":"json_object_array.py\n\"\"\"Script writes an array of objects to stdout\"\"\" import json import sys args = sys.argv[1:] # Make a list of dictionaries from the given args, one dict per arg my_array = [{arg.upper(): len(arg)} for arg in args] # Cast to JSON and print to stdout print(json.dumps(my_array)) ","r#R":"json_object_array.R\n# Script writes a JSON array of objects to stdout library(jsonlite) # Get the command-line arguments args \u003c- commandArgs(trailingOnly = TRUE) # Create an array of named lists from the given args, one list per arg myArray \u003c- list() for (arg in args) { string_length \u003c- list() string_length[[toupper(arg)]] \u003c- nchar(arg) myArray[[length(myArray)+1]] \u003c- string_length } # Convert the array to a JSON array and print to stdout cat(toJSON(myArray, auto_unbox=TRUE)) ","raku#Raku":"json_object_array.raku\n# Script outputs arrays of objects as JSON use v6; use JSON::Fast; say to-json(@*ARGS.map: { uc($_) =\u003e $_.chars }); ","ruby#Ruby":"json_object_array.rb\n# Script outputs arrays of objects as JSON require 'json' my_strings = ARGV # Make a list of dictionaries from the given arguments, one dict per arg my_array = my_strings.map { |string| {string.upcase =\u003e string.length} } # Cast to JSON and print to stdout puts JSON.generate(my_array) ","rust#Rust":"json_object_array.rs\n//cargo-deps: json=\"0.12.4\" // Script outputs arrays of objects as JSON use json::JsonValue; use std::env; use json::object; extern crate json; fn main() { let args = env::args().skip(1); let json_array = JsonValue::Array( args.into_iter() .map(|string| { object! { string.to_uppercase().as_str() =\u003e string.len() } }) .collect(), ); println!(\"{}\", json_array.dump()); } ","swift#Swift":"json_object_array.swift\n//Script writes an array of objects to stdout import Foundation guard CommandLine.arguments.count \u003e 1 else { print(\"Usage: swift script.swift \u003carg1\u003e [\u003carg2\u003e ...]\") exit(1) } let args = CommandLine.arguments.dropFirst() let myArray = args.map { [$0.uppercased(): $0.count] } let jsonData = try JSONSerialization.data(withJSONObject: myArray) print(String(data: jsonData, encoding: .utf8)!) "},"title":"json_object_array"},"/io_operations/json_object_with_array_values/":{"data":{"c#C#":"JsonObjectWithArrayValues.cs\n// Script takes arguments and transforms them into dict with arrays as dict values and returns as JSON using System; using System.Collections.Generic; using System.Text; using System.Text.Json; class JsonObjectWithArrayValues{ public static void Main(string[] args){ var jsonObject = args.ToDictionary( str =\u003e str, str =\u003e str.ToUpper().Select(c =\u003e c.ToString()).ToList() ); string jsonString = JsonSerializer.Serialize(jsonObject); Console.WriteLine(jsonString); } } ","deno#Deno":"json_object_with_array_values.mjs\n// Script takes command line args and transforms into python dict with arrays as dict values const myStrings = Deno.args const stringLettersDict = {} for (const string of myStrings) { const uppercaseLetters = [...string].map((s) =\u003e s.toUpperCase()) stringLettersDict[string] = uppercaseLetters } console.log(JSON.stringify(stringLettersDict)) ","go#Go":"json_object_with_array_values.go\n// Script takes arguments and transforms them into dict with arrays as dict values // and returns as JSON package main import ( \"encoding/json\" \"fmt\" \"os\" \"strings\" ) func main() { args := os.Args[1:] jsonObject := make(map[string][]string) for _, str := range args { var lettersArray []string for _, char := range strings.ToUpper(str) { lettersArray = append(lettersArray, string(char)) } jsonObject[str] = lettersArray } jsonObjectBytes, _ := json.Marshal(jsonObject) fmt.Println(string(jsonObjectBytes)) } ","java#Java":"JsonObjectWithArrayValues.java\n// Script takes arguments and transforms them into dict with arrays as dict values // and returns as JSON import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.ObjectNode; import java.util.Arrays; public class JsonObjectWithArrayValues { public static void main(String[] args) throws Exception{ if (args.length == 0) { System.out.println(\"Usage: java JsonFromStrings \u003cstring1\u003e \u003cstring2\u003e ...\"); System.exit(1); } ObjectMapper objectMapper = new ObjectMapper(); ObjectNode jsonObject = objectMapper.createObjectNode(); Arrays.stream(args).forEach(str -\u003e { ArrayNode lettersArray = objectMapper.createArrayNode(); str.toUpperCase().chars().forEach(c -\u003e lettersArray.add(String.valueOf((char) c))); jsonObject.set(str, lettersArray); }); String jsonString = objectMapper.writeValueAsString(jsonObject); System.out.println(jsonString); } } ","json_object_with_array_values#json_object_with_array_values":"json_object_with_array_valuesTest that a JSON object with arrays as values is parsed correctly","lua#Lua":"json_object_with_array_values.lua\n-- Lua script to transform string arguments into a Lua table of arrays and output as JSON local cjson = require(\"dkjson\") local string_letters_dict = {} for i = 1, #arg do local string = arg[i] local letters = {} for letter in string:gmatch(\".\") do table.insert(letters, letter:upper()) end string_letters_dict[string] = letters end print(cjson.encode(string_letters_dict)) ","nodejs#Nodejs":"json_object_with_array_values.mjs\n// Script takes command line args and transforms into python dict with arrays as dict values const myStrings = process.argv.slice(2) const stringLettersDict = {} for (const string of myStrings) { const uppercaseLetters = [...string].map((s) =\u003e s.toUpperCase()) stringLettersDict[string] = uppercaseLetters } console.log(JSON.stringify(stringLettersDict)) ","perl#Perl":"json_object_with_array_values.pl\nuse strict; use warnings; use JSON; print JSON-\u003enew -\u003ecanonical(1) -\u003eencode({ map { $_ =\u003e [split //, uc($_)] } @ARGV }); ","php#Php":"json_object_with_array_values.php\n\u003c?php // Script takes args and transforms into python dict with arrays as dict values // Get the command-line arguments into an array $myStrings = array_slice($argv, 1); // Create an associative array (dictionary) with each string as a key and an array of letters as the value $stringLettersDict = array_combine( $myStrings, array_map( fn($str) =\u003e str_split(strtoupper($str)), $myStrings ) ); // Encode the dictionary as JSON and print to stdout echo json_encode($stringLettersDict) . \"\\n\"; ","python#Python":"json_object_with_array_values.py\n\"\"\"Script takes args and transforms into python dict with arrays as dict values\"\"\" import json import sys my_strings = sys.argv[1:] # Make dict with the string as key and list of letters as value string_letters_dict = {string: [s.upper() for s in string] for string in my_strings} # Cast to JSON and print to stdout print(json.dumps(string_letters_dict)) ","r#R":"json_object_with_array_values.R\n#' Script transforms command-line arguments into JSON object library(jsonlite) # Get the command-line arguments (strings) args \u003c- commandArgs(trailingOnly = TRUE) # Create a named list with the string as the key and a list of uppercase letters as the value string_letters \u003c- list() for (string in args) { letters \u003c- toupper(strsplit(string, split=\"\")[[1]]) string_letters[[string]] \u003c- letters } # Convert the named list to JSON and print to stdout cat(toJSON(string_letters)) ","raku#Raku":"json_object_with_array_values.raku\nuse v6; use JSON::Fast; my %data = @*ARGS.map: { $_ =\u003e [ .uc.comb ] }; say to-json(%data); ","ruby#Ruby":"json_object_with_array_values.rb\n# Script takes arguments and transforms them into dict with arrays as dict values # and returns as JSON require 'json' my_strings = ARGV # Make dict with the string as key and list of letters as value string_letters_dict = my_strings.to_h { |string| [string, string.upcase.chars] } # Cast to JSON and print to stdout puts JSON.generate(string_letters_dict) ","rust#Rust":"json_object_with_array_values.rs\n//cargo-deps: json=\"0.12.4\" // Script takes arguments and transforms them into dict with arrays as dict values // and returns as JSON use json::JsonValue; use std::env; extern crate json; fn main() { let args: Vec\u003cString\u003e = env::args().skip(1).collect(); let mut json_object = JsonValue::new_object(); for arg in args { let letters_array: JsonValue = arg .to_uppercase() .chars() .map(|c| c.to_string().into()) .collect::\u003cVec\u003cJsonValue\u003e\u003e() .into(); json_object[arg] = letters_array; } println!(\"{}\", json_object.dump()); } ","swift#Swift":"json_object_with_array_values.swift\n//Script takes args and transforms into python dict with arrays as dict values import Foundation guard CommandLine.arguments.count \u003e 1 else { print(\"Usage: swift script.swift \u003carg1\u003e [\u003carg2\u003e ...]\") exit(1) } let myStrings = CommandLine.arguments.dropFirst() let stringLettersDict = Dictionary(uniqueKeysWithValues: myStrings.map { ($0, $0.map { String($0).uppercased() }) }) let jsonData = try JSONSerialization.data(withJSONObject: stringLettersDict) print(String(data: jsonData, encoding: .utf8)!) "},"title":"json_object_with_array_values"},"/io_operations/json_stdout_object/":{"data":{"c#C#":"JsonStdoutObject.cs\n// Script reads string args and transforms into python dict using System; using System.Collections.Generic; using System.Text; using System.Text.Json; class JsonStdoutObject{ public static void Main(string[] args){ Dictionary\u003cstring, int\u003e stringLengthDict = new Dictionary\u003cstring, int\u003e(); foreach (string str in args){ stringLengthDict[str] = str.Length; } string jsonString = JsonSerializer.Serialize(stringLengthDict); Console.WriteLine(jsonString); } } ","deno#Deno":"json_stdout_object.mjs\n// Script reads string args and transforms into python dict const myStrings = Deno.args // Make a dict with each string as a key and it's length as the value const stringLengthDict = {} for (const string of myStrings) { stringLengthDict[string] = string.length } console.log(JSON.stringify(stringLengthDict)) ","go#Go":"json_stdout_object.go\n// Script reads string args and transforms into python dict package main import ( \"encoding/json\" \"fmt\" \"os\" ) func main() { args := os.Args[1:] stringLengthMap := make(map[string]int) for _, arg := range args { stringLengthMap[arg] = len(arg) } jsonObjectBytes, _ := json.Marshal(stringLengthMap) fmt.Println(string(jsonObjectBytes)) } ","java#Java":"JsonStdoutObject.java\n// Script reads string args and transforms into python dict import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import java.util.HashMap; import java.util.Map; public class JsonStdoutObject { public static void main(String[] args) throws Exception{ if (args.length == 0) { System.out.println(\"Usage: java JsonStdoutObject \u003cstring1\u003e \u003cstring2\u003e ...\"); System.exit(1); } ObjectMapper objectMapper = new ObjectMapper(); ObjectNode jsonObject = objectMapper.createObjectNode(); Map\u003cString, Integer\u003e stringLengthDict = new HashMap\u003c\u003e(); for (String string : args) { jsonObject.put(string, string.length()); } String jsonString = objectMapper.writeValueAsString(jsonObject); System.out.println(jsonString); } } ","json_stdout_object#json_stdout_object":"json_stdout_objectTest that JSON object is parsed correctly","lua#Lua":"json_stdout_object.lua\n-- Lua script to transform string arguments into a Lua table and output as JSON local cjson = require(\"dkjson\") local dict = {} for i = 1, #arg do dict[arg[i]] = arg[i]:len() end print(cjson.encode(dict)) ","nodejs#Nodejs":"json_stdout_object.mjs\n// Script reads string args and transforms into python dict const myStrings = process.argv.slice(2) // Make a dict with each string as a key and it's length as the value const stringLengthDict = {} for (const string of myStrings) { stringLengthDict[string] = string.length } console.log(JSON.stringify(stringLengthDict)) ","perl#Perl":"json_stdout_object.pl\n# Script reads string args and transforms into python dict use strict; use warnings; use JSON; print encode_json({ map { $_ =\u003e length } @ARGV }); ","php#Php":"json_stdout_object.php\n\u003c?php // Script reads string args and transforms into python dict // Get the command-line arguments into an array $myStrings = array_slice($argv, 1); // Create an associative array (dictionary) with each string as a key and its length as the value $stringLengthDict = array_combine($myStrings, array_map('strlen', $myStrings)); // Encode the dictionary as JSON and print to stdout echo json_encode($stringLengthDict) . \"\\n\"; ","python#Python":"json_stdout_object.py\n\"\"\"Script reads string args and transforms into python dict\"\"\" import json import sys my_strings = sys.argv[1:] # Make a dict with each string as a key and it's length as the value string_length_dict = {string: len(string) for string in my_strings} # Cast to JSON and print to stdout print(json.dumps(string_length_dict)) ","r#R":"json_stdout_object.R\n#' Script reads string arguments and transforms to JSON object library(jsonlite) # Get the command-line arguments (strings) args \u003c- commandArgs(trailingOnly = TRUE) # Create a named list with each string as a key and its length as an atomic vector string_length \u003c- list() for (string in args) { string_length[[string]] \u003c- nchar(string) } # Convert list to JSON and print to stdout # `auto_unbox`flag marks atomic vectors as singletons with 1 element so that the # value won't turn into an array when encoded into JSON cat(toJSON(string_length, auto_unbox = TRUE)) ","raku#Raku":"json_stdout_object.raku\n# Script reads string args and transforms into python dict use v6; use JSON::Fast; my %data = @*ARGS.map: { $_ =\u003e .chars }; say to-json(%data); ","ruby#Ruby":"json_stdout_object.rb\n# Script reads string args and transforms into python dict require 'json' my_strings = ARGV # Make a dict with each string as a key and it's length as the value string_length_dict = my_strings.to_h { |string| [string, string.length] } # Cast to JSON and print to stdout puts JSON.generate(string_length_dict) ","rust#Rust":"json_stdout_object.rs\n//cargo-deps: json=\"0.12.4\" // Script reads string args and transforms into dict use json::JsonValue; use std::env; extern crate json; fn main() { let args = env::args().skip(1); let mut json_object = JsonValue::new_object(); for arg in args { json_object[arg] = arg.len().into(); } println!(\"{}\", json_object.dump()); } ","swift#Swift":"json_stdout_object.swift\n//Script reads string args and transforms into python dict import Foundation guard CommandLine.arguments.count \u003e 1 else { print(\"Usage: swift script.swift \u003carg1\u003e [\u003carg2\u003e ...]\") exit(1) } let myStrings = CommandLine.arguments.dropFirst() let stringLengthDict = Dictionary(uniqueKeysWithValues: myStrings.map { ($0, $0.count) }) let jsonData = try JSONSerialization.data(withJSONObject: stringLengthDict) print(String(data: jsonData, encoding: .utf8)!) "},"title":"json_stdout_object"},"/io_operations/null_char/":{"data":{"bash-3#Bash 3":"null_char.sh\nprintf \"Hello World \\0\\n\" ","bash-5#Bash 5":"null_char.sh\nprintf \"Hello World \\0\\n\" ","c#C#":"NullChar.cs\nclass NullChar { public static void Main(string[] args) { Console.WriteLine(\"Hello World \\0\"); } } ","deno#Deno":"null_char.mjs\n// Script to write null character to stdout console.log(\"Hello World \\0\") ","go#Go":"null_char.go\npackage main import \"fmt\" func main() { fmt.Println(\"Hello World \\x00\") } ","java#Java":"NullChar.java\npublic class NullChar { public static void main(String[] args) { System.out.println(\"Hello World \\0\"); } } ","lua#Lua":"null_char.lua\nprint(\"Hello World \\0\") ","nodejs#Nodejs":"null_char.mjs\n// Script to write null character to stdout console.log(\"Hello World \\0\") ","null_char#null_char":"null_charTest outputing a null character","perl#Perl":"null_char.pl\nuse strict; use warnings; print \"Hello World \\0\\n\" ","php#Php":"null_char.php\n\u003c?php // Write null character to stdout // echo function does not add a new line so adding it here manually // for consistency with other langauges echo \"Hello World \\0\\n\"; ","python#Python":"null_char.py\nprint(\"Hello World \\0\") ","r#R":"null_char.R\n#' Write the null character to stdout # R character strings don't support the null character # so we convert the strings to raw vectors text_raw \u003c- charToRaw(\"Hello World \") null_char_raw \u003c- as.raw(0) new_line_raw \u003c- charToRaw(\"\\n\") raw_vector \u003c- c(text_raw, null_char_raw, new_line_raw) # Write to a temporary binary file writeBin(raw_vector, \"temp_binary_file.bin\") # Read file to stdout, intern=FALSE so output is not captured as a character vector system(\"cat temp_binary_file.bin\", intern = FALSE) # Delete the temp file unlink(\"temp_binary_file.bin\") ","raku#Raku":"null_char.raku\nuse v6; print \"Hello World \\0\\n\"; ","ruby#Ruby":"null_char.rb\nputs \"Hello World \\0\" ","rust#Rust":"null_char.rs\nfn main() { println!(\"Hello World \\0\"); } ","swift#Swift":"null_char.swift\nprint(\"Hello World \\0\") "},"title":"null_char"},"/io_operations/read_file/":{"data":{"bash-3#Bash 3":"read_file.sh\n#!/bin/bash # Read a file from file path (given as a command line arg), # print line by line with line numbers file_path=\"$1\" if [ ! -f \"$file_path\" ]; then echo \"File not found: $file_path\" exit 1 fi i=1 while IFS= read -r line; do echo \"$((i++)) $(tr '[:lower:]' '[:upper:]' \u003c\u003c\u003c \"$line\")\" done \u003c \"$file_path\" ","bash-5#Bash 5":"read_file.sh\n#!/bin/bash # Read a file from file path (given as a command line arg), # print line by line with line numbers file_path=\"$1\" if [ ! -f \"$file_path\" ]; then echo \"File not found: $file_path\" exit 1 fi i=1 while IFS= read -r line; do echo \"$((i++)) ${line^^}\" done \u003c \"$1\" ","c#C#":"ReadFile.cs\n// Read a file from file path (given as a command line arg), // print line by line with line numbers using System; using System.IO; using System.Linq; class ReadFile { public static void Main (string[] args) { string filePath = args[0]; var lines = File.ReadAllLines(filePath); lines.Select((line, index) =\u003e $\"{index + 1} {line.ToUpper()}\") .ToList() .ForEach(Console.WriteLine); } } ","deno#Deno":"read_file.mjs\n// Read a file (file path given as a command line argument) and write to stdout const filePath = Deno.args[0]; const file = await Deno.open(filePath); const decoder = new TextDecoder(); let i = 1; let partialLine = ''; for await (const chunk of Deno.iter(file)) { const chunkStr = decoder.decode(chunk, { stream: true }); const lines = (partialLine + chunkStr).split('\\n'); for (const line of lines.slice(0, -1)) { console.log(`${i++} ${line.toUpperCase()}`); } partialLine = lines[lines.length - 1]; } if (partialLine) { console.log(`${i} ${partialLine.toUpperCase()}`); } file.close(); ","go#Go":"read_file.go\n// Read a file from file path (given as a command line arg), // print line by line with line numbers package main import ( \"fmt\" \"os\" \"strings\" ) func main() { content, _ := os.ReadFile(os.Args[1]) lines := strings.Split(string(content), \"\\n\") lineNumber := 1 for _, line := range lines { if line == \"\" { continue } fmt.Printf(\"%d %s\\n\", lineNumber, strings.ToUpper(line)) lineNumber++ } } ","java#Java":"ReadFile.java\n// Read a file from file path (given as a command line arg), // print line by line with line numbers import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.concurrent.atomic.AtomicInteger; class ReadFile{ public static void main(String[] args) throws IOException { var filePath = Paths.get(args[0]); var lineNumber = new AtomicInteger(1); Files.lines(filePath) .map(String::toUpperCase) .map(line -\u003e lineNumber.getAndIncrement() + \" \" + line) .forEach(System.out::println); } } ","lua#Lua":"read_file.lua\n-- Lua script to read input, transform to uppercase, and print with line numbers local file_path = arg[1] local fh = io.open(file_path, \"r\") local i = 1 for line in fh:lines() do print(i .. \" \" .. line:upper()) i = i + 1 end ","nodejs#Nodejs":"read_file.mjs\n// Read a file (file path given as a command line argument), // and write to stdout import * as readline from 'node:readline/promises' import fs from 'fs' // Get the file path from the command-line argument const file_path = process.argv[2] const rl = readline.createInterface({ input: fs.createReadStream(file_path), }) let i = 1 for await (const line of rl) { console.log(i + \" \" + line.toUpperCase()) i++ } ","perl#Perl":"read_file.pl\n# Read a file from file path (given as a command line arg), # print line by line with line numbers use strict; use warnings; my $file_path = shift; open my $fh, '\u003c', $file_path or die \"Cannot open file: $file_path\\n\"; my $i = 1; print $i++ . \" \" . uc while \u003c$fh\u003e; ","php#Php":"read_file.php\n\u003c?php /* Read a file (file path given as a command line argument), and write to stdout */ // Get the file path from command line arguments $file_path = $argv[1]; // Open the file for reading $file = fopen($file_path, 'r'); foreach (file($file_path) as $index =\u003e $line) { echo ($index + 1) . ' ' . strtoupper($line); } ","python#Python":"read_file.py\n\"\"\"Read a file (file path given as a command line argument), and write to stdout \"\"\" import sys file_path = sys.argv[1] with open(file_path, 'r') as f: i = 1 for line in f.readlines(): print(i, line.upper(), end='') i += 1 ","r#R":"read_file.R\n#' Read a file (file path given as a command line argument), #' and write to stdout # Get the file path from the command line argument file_path \u003c- commandArgs(trailingOnly = TRUE)[1] # Open the file for reading con \u003c- file(file_path, \"r\") # Read and print lines from the file i \u003c- 1 while (length(line \u003c- readLines(con, n = 1)) \u003e 0) { cat(i, toupper(line), sep = \" \", fill = TRUE) i \u003c- i + 1 } # Close the file connection close(con) ","raku#Raku":"read_file.raku\n# Read a file from file path (given as a command line arg), # print line by line with line numbers use v6; my $file-path = @*ARGS.shift; my $fh = open $file-path, :r; my $i = 1; for $fh.lines { say $i++ ~ \" \" ~ .uc; } $fh.close; ","read_file#read_file":"read_fileCheck that a file is read line by line, when file path is given as command line argument","ruby#Ruby":"read_file.rb\n# Read a file from file path (given as a command line arg), # print line by line with line numbers file_path = ARGV[0] begin File.open(file_path, 'r') do |f| f.each_line.with_index do |line, i| puts \"#{i+1} #{line.upcase}\" end end rescue Errno::ENOENT puts \"File not found: #{file_path}\" exit(1) end ","rust#Rust":"read_file.rs\nuse std::env; use std::fs::File; use std::io::{BufRead, BufReader}; fn main() { let file_path = env::args().nth(1).unwrap(); let file = File::open(file_path).unwrap(); let reader = BufReader::new(file); for (line_number, line_result) in reader.lines().enumerate() { let line = line_result.unwrap(); println!(\"{} {}\", line_number + 1, line.to_uppercase()); } } ","swift#Swift":"read_file.swift\n//Read a file (file path given as a command line argument) and write to stdout import Foundation guard CommandLine.arguments.count \u003e 1 else { print(\"Usage: swift script.swift \u003cfile_path\u003e\") exit(1) } let fileContents = try String(contentsOfFile: CommandLine.arguments[1]) var i = 1 fileContents.enumerateLines { line, _ in print(\"\\(i) \\(line.uppercased())\") i += 1 } "},"title":"read_file"},"/io_operations/read_json_file/":{"data":{"c#C#":"ReadJsonFile.cs\n// Read JSON file, transform and print to stdout using System; using System.IO; using System.Text.Json; class ReadJsonFile{ public static void Main(string[] args){ string jsonFilePath = args[0]; string jsonContent = File.ReadAllText(jsonFilePath); JsonElement root = JsonDocument.Parse(jsonContent).RootElement; foreach (JsonElement person in root.EnumerateArray()){ long age = person.GetProperty(\"age\").GetInt64(); string firstName = person.GetProperty(\"first_name\").GetString(); Console.WriteLine($\"Hello, {age} year old {firstName}\"); } } } ","deno#Deno":"read_json_file.mjs\n// Read JSON file, transform and print to stdout const jsonFile = Deno.args[0]; const data = await Deno.readTextFile(jsonFile); const people = JSON.parse(data); for (const person of people) { console.log(`Hello, ${person.age} year old ${person.first_name}`); } ","go#Go":"read_json_file.go\npackage main import ( \"encoding/json\" \"fmt\" \"os\" ) type Person struct { FirstName string `json:\"first_name\"` Age int64 `json:\"age\"` } func main() { file := os.Args[1] data, _ := os.ReadFile(file) var people []Person json.Unmarshal(data, \u0026people) for _, person := range people { fmt.Printf(\"Hello, %d year old %s\\n\", person.Age, person.FirstName) } } ","java#Java":"ReadJsonFile.java\n// Read JSON file, transform and print to stdout import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.File; import java.io.IOException; public class ReadJsonFile { public static void main(String[] args) throws IOException{ if (args.length \u003c 1) { System.out.println(\"Usage: java ReadJsonFile \u003cjson_file\u003e\"); return; } JsonNode people = new ObjectMapper().readTree(new File(args[0])); people.forEach(person -\u003e System.out.println(\"Hello, \" + person.get(\"age\").asLong() + \" year old \" + person.get(\"first_name\").asText())); } } ","lua#Lua":"read_json_file.lua\n-- Lua script to read JSON file, parse, and print to stdout local cjson = require(\"dkjson\") local file_path = arg[1] local fh = io.open(file_path, \"r\") local json_content = fh:read(\"*a\") fh:close() local people = cjson.decode(json_content) for _, person in ipairs(people) do print(string.format(\"Hello, %d year old %s\", person.age, person.first_name)) end ","nodejs#Nodejs":"read_json_file.mjs\n// Read JSON file, transform and print to stdout import fs from 'fs/promises' const jsonFile = process.argv[2] const data = await fs.readFile(jsonFile, 'utf8') const people = JSON.parse(data) for (const person of people) { console.log(`Hello, ${person.age} year old ${person.first_name}`) } ","perl#Perl":"read_json_file.pl\n# Read JSON file, transform and print to stdout use strict; use warnings; use JSON; open my $fh, '\u003c', $ARGV[0] or die \"Cannot open file: $ARGV[0]\\n\"; my $people = decode_json(do { local $/; \u003c$fh\u003e }); print \"Hello, $_-\u003e{'age'} year old $_-\u003e{'first_name'}\\n\" for @$people; ","php#Php":"read_json_file.php\n\u003c?php // Read JSON file, transform, and print to stdout $jsonFile = $argv[1]; // Read JSON data from the file $jsonData = file_get_contents($jsonFile); // Parse JSON data $people = json_decode($jsonData); foreach ($people as $person) { echo \"Hello, {$person-\u003eage} year old {$person-\u003efirst_name}\\n\"; } ","python#Python":"read_json_file.py\n\"\"\"Read JSON file, transform and print to stdout\"\"\" import json import sys json_file = sys.argv[1] with open(json_file, \"r\") as f: people = json.load(f) for person in people: print(f\"Hello, {person['age']} year old {person['first_name']}\") ","r#R":"read_json_file.R\n#' Read JSON file, transform and print to stdout library(jsonlite) # Get the JSON file path from the command line arguments args \u003c- commandArgs(trailingOnly = TRUE) # Read and parse the JSON file as a list of named lists people \u003c- fromJSON(args[1]) # Iterate through the list of people and print the transformed message for (i in 1:nrow(people)){ cat(paste0(\"Hello, \", people$age[i], \" year old \", people$first_name[i], \"\\n\")) } ","raku#Raku":"read_json_file.raku\n# Read JSON file, transform and print to stdout use v6; use JSON::Fast; my $file-path = @*ARGS[0]; my $fh = open $file-path, :r; my $people = from-json($fh.slurp-rest); for @$people -\u003e $person { say \"Hello, {$person\u003cage\u003e} year old {$person\u003cfirst_name\u003e}\"; } $fh.close; ","read_json_file#read_json_file":"read_json_fileTest that a JSON file is read correctly","ruby#Ruby":"read_json_file.rb\n# Read JSON file, transform and print to stdout require 'json' json_file = ARGV[0] people = JSON.load_file(json_file) people.each do |person| puts \"Hello, #{person['age']} year old #{person['first_name']}\" end ","rust#Rust":"read_json_file.rs\n//cargo-deps: json=\"0.12.4\" use std::env; use std::fs; extern crate json; fn main() { let filename = env::args().nth(1).unwrap(); let json_string = fs::read_to_string(filename).unwrap(); let parsed_json = json::parse(\u0026json_string).unwrap(); let people = parsed_json.members(); for person in people { let age = person[\"age\"].as_u32().unwrap(); let first_name = person[\"first_name\"].as_str().unwrap(); println!(\"Hello, {} year old {}\", age, first_name); } } ","swift#Swift":"read_json_file.swift\n//Read JSON file, transform and print to stdout import Foundation guard let jsonFile = CommandLine.arguments.dropFirst().first else { print(\"Usage: swift script.swift \u003cjson_file\u003e\") exit(1) } let fileURL = URL(fileURLWithPath: jsonFile) let jsonData = try Data(contentsOf: fileURL) let people = try JSONSerialization.jsonObject(with: jsonData) as! [[String: Any]] for (_, person) in people.enumerated() { let age = person[\"age\"] as! Int let firstName = person[\"first_name\"] as! String print(\"Hello, \\(age) year old \\(firstName)\") } "},"title":"read_json_file"},"/io_operations/stdin/":{"data":{"bash-3#Bash 3":"stdin.sh\n#!/bin/bash # Test script to get input, transform, and write to stdout i=1 while IFS= read -r user_input; do echo \"$((i++)) $user_input\" done | tr '[:lower:]' '[:upper:]' ","bash-5#Bash 5":"stdin.sh\n#!/bin/bash i=1 while IFS= read -r user_input; do echo \"$((i++)) ${user_input^^}\" done ","c#C#":"Stdin.cs\n// Test script to get input, transform, and write to stdout using System; using System.Collections.Generic; using System.Linq; class Stdin { public static void Main(string[] args) { string line; int counter = 1; while ((line = Console.ReadLine()) != null) { Console.WriteLine($\"{counter++} {line.ToUpper()}\"); } } } ","deno#Deno":"stdin.mjs\n// Script to read stdin line by line, transform, and write to stdout import { readLines } from 'https://deno.land/std/io/mod.ts'; const rl = readLines(Deno.stdin); let i = 1; for await (const line of rl) { console.log(i, line.toUpperCase()); i += 1; } ","go#Go":"stdin.go\n// Test script to get input, transform, and write to stdout package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { scanner := bufio.NewScanner(os.Stdin) for lineNumber := 1; scanner.Scan(); lineNumber++ { fmt.Printf(\"%d %s\\n\", lineNumber, strings.ToUpper(scanner.Text())) } } ","java#Java":"Stdin.java\n// Test script to get input, transform, and write to stdout import java.util.Scanner; import java.util.concurrent.atomic.AtomicInteger; import java.util.stream.Stream; public class Stdin { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); AtomicInteger counter = new AtomicInteger(1); // Create a stream of lines from Scanner Stream.generate(scanner::nextLine) .takeWhile(line -\u003e !line.isEmpty()) // Assuming empty line signals end, adjust as needed .forEach(line -\u003e System.out.println(counter.getAndIncrement() + \" \" + line.toUpperCase())); scanner.close(); } } ","lua#Lua":"stdin.lua\n-- Lua script to read input, transform to uppercase, and print with line numbers local i = 1 -- Read from stdin until EOF for user_input in io.lines() do -- Transform input to uppercase and prepend with line number print(i .. \" \" .. user_input:upper()) i = i + 1 end ","nodejs#Nodejs":"stdin.mjs\n// Script to read stdin line by line, transform, and write to stdout import * as readline from 'node:readline/promises' const rl = readline.createInterface({ input: process.stdin }) let i = 1 for await (const line of rl) { console.log(i, line.toUpperCase()) i += 1 } ","perl#Perl":"stdin.pl\n# Test script to get input, transform, and write to stdout use strict; use warnings; my $i = 1; print $i++ . \" \" . uc while \u003cSTDIN\u003e; ","php#Php":"stdin.php\n\u003c?php // Script to read stdin line by line, transform, and return it $i = 1; while ($user_input = fgets(STDIN)) { // fgets returns false when nothing left to read echo $i++ . ' ' . strtoupper($user_input); } ","python#Python":"stdin.py\n\"\"\"Script to read stdin line by line, transform, and return it\"\"\" i = 1 while True: try: user_input = input() print(i, user_input.upper()) i += 1 except EOFError: break ","r#R":"stdin.R\n#' Script to read stdin, transform, and return it i \u003c- 1 for (line in readLines(\"stdin\")) { cat(i, toupper(line), sep = \" \", fill = TRUE) # fill flag adds new line i \u003c- i + 1 } ","raku#Raku":"stdin.raku\n# Test script to get input, transform, and write to stdout use v6; my $i = 1; for lines() { say $i++ ~ \" \" ~ .uc; } ","ruby#Ruby":"stdin.rb\n# Test script to get input, transform, and write to stdout i = 1 while user_input = gets puts \"#{i} #{user_input.upcase}\" i += 1 end ","rust#Rust":"stdin.rs\n// Test script to get input, transform, and write to stdout use std::io::{self, BufRead}; fn main() { let stdin = io::stdin(); for (counter, line) in stdin.lock().lines().enumerate() { let line = line.unwrap().trim().to_string(); if line.is_empty() { break; } println!(\"{} {}\", counter + 1, line.to_uppercase()); } } ","stdin#stdin":"stdinCheck that input is read from stdin, line by line. The script executed in the docker container accepts a text file as input, reads each line, capitalizes it, then prints it out.","swift#Swift":"stdin.swift\n//Script to read stdin line by line, transform, and return it import Foundation var i = 1 while let user_input = readLine() { print(\"\\(i) \\(user_input.uppercased())\") i += 1 } "},"title":"stdin"},"/io_operations/streaming_pipe_in/":{"data":{"bash-3#Bash 3":"streaming_pipe_in.sh\n#!/bin/bash # Script reads text from a named pipe and writes it to stdout, capitalized pipe_in=\"$1\" tr '[:lower:]' '[:upper:]' \u003c \"$pipe_in\" ","bash-5#Bash 5":"streaming_pipe_in.sh\n#!/bin/bash # Script reads text from a named pipe and writes it to stdout, capitalized pipe_in=\"$1\" tr '[:lower:]' '[:upper:]' \u003c \"$pipe_in\" ","c#C#":"StreamingPipeIn.cs\n// Script reads text from a named pipe and writes it to stdout, capitalized using System; using System.IO; using System.Text; class StreamingPipeIn { public static void Main(string[] args) { string pipe_in = args[0]; using var reader = new StreamReader(args[0]); string line; while ((line = reader.ReadLine()) != null) { Console.WriteLine(line.ToUpper()); } } } ","deno#Deno":"streaming_pipe_in.mjs\n//Script reads text from a named pipe and writes it to stdout, capitalized import { readLines } from 'https://deno.land/std/io/mod.ts'; const [pipePath] = Deno.args; const file = await Deno.open(pipePath, { read: true }); for await (const line of readLines(file)) { console.log(line.toUpperCase()); } file.close(); ","go#Go":"streaming_pipe_in.go\n//Script reads text from a named pipe and writes it to stdout, capitalized package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { pipeIn := os.Args[1] file, _ := os.Open(pipeIn) defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Text() fmt.Println(strings.ToUpper(line)) } } ","java#Java":"StreamingPipeIn.java\n//Script reads text from a named pipe and writes it to stdout, capitalized import java.io.*; public class StreamingPipeIn { public static void main(String[] args) throws IOException { String pipe_in = args[0]; BufferedReader input = new BufferedReader(new FileReader(pipe_in)); String line; while ((line = input.readLine()) != null) { System.out.println(line.toUpperCase()); } input.close(); } } ","lua#Lua":"streaming_pipe_in.lua\n-- Script reads text from a named pipe and writes it to stdout, capitalized local pipe_in = arg[1] local input_file = assert(io.open(pipe_in, \"r\"), \"Failed to open input pipe: \" .. pipe_in) for line in input_file:lines() do io.write(line:upper() .. \"\\n\") io.flush() end input_file:close() ","nodejs#Nodejs":"streaming_pipe_in.mjs\n//Script reads text from a named pipe and writes it to stdout, capitalized import * as fs from 'fs'; import * as readline from 'node:readline/promises'; const pipeIn = process.argv[2]; const input = fs.createReadStream(pipeIn); const rl = readline.createInterface({ input }) for await (const line of rl) { console.log(line.toUpperCase()) } ","perl#Perl":"streaming_pipe_in.pl\n# Script reads text from a named pipe and writes it to stdout, capitalized use strict; use warnings; $| = 1; # Turn off output buffering my ($pipe_in) = @ARGV; open my $input, '\u003c', $pipe_in or die \"Cannot open input pipe: $!\"; while (my $line = \u003c$input\u003e) { print uc($line); } close $input; ","php#Php":"streaming_pipe_in.php\n\u003c?php // Script reads text from a named pipe and writes it to stdout, capitalized $pipe_in = $argv[1]; $input_pipe = fopen($pipe_in, 'r'); while (($line = fgets($input_pipe)) !== false) { echo strtoupper($line); } fclose($input_pipe); ?\u003e ","python#Python":"streaming_pipe_in.py\nimport sys pipe_in = sys.argv[1] with open(pipe_in, 'r', encoding='utf-8') as input_pipe: for line in input_pipe: sys.stdout.write(line.upper()) sys.stdout.flush() ","r#R":"streaming_pipe_in.R\n# Script reads text from a named pipe and writes it to stdout, capitalized # Command-line arguments args \u003c- commandArgs(trailingOnly = TRUE) # Named pipe path (input) pipe_in \u003c- args[1] # Open named pipe for reading input \u003c- file(pipe_in, \"r\") # Read each line from input pipe, convert to uppercase, and print to stdout while (length(line \u003c- readLines(input, n = 1)) \u003e 0) { cat(paste(toupper(line), \"\\n\", sep = \"\")) # Print capitalized line to stdout } # Close input pipe close(input) ","raku#Raku":"streaming_pipe_in.raku\nuse v6; my $pipe_in = @*ARGS[0]; my $input = open($pipe_in, :r); for $input.lines() { say .uc; $*OUT.flush; } $input.close; ","ruby#Ruby":"streaming_pipe_in.rb\n# Script reads text from a named pipe and writes it to stdout, capitalized STDOUT.sync = true pipe_in = ARGV.fetch(0) File.open(pipe_in, 'r') do |pipe| pipe.each_line do |line| puts line.upcase end end ","rust#Rust":"streaming_pipe_in.rs\n//Script reads text from a named pipe and writes it to stdout, capitalized use std::env; use std::fs::File; use std::io::{BufRead, BufReader}; fn main() { let pipe_in = env::args().nth(1).unwrap(); let file = File::open(pipe_in).unwrap(); let reader = BufReader::new(file); for line in reader.lines() { println!(\"{}\", line.unwrap().to_uppercase()); } } ","streaming_pipe_in#streaming_pipe_in":"streaming_pipe_inTest that named pipe can be read line by line and can write to stdout","swift#Swift":"streaming_pipe_in.swift\nimport Foundation #if os(macOS) || os(iOS) import Darwin #elseif os(Linux) import Glibc #endif setvbuf(stdout, nil, _IONBF, 0) let arguments = CommandLine.arguments let pipe_in = arguments[1] public class FileLines: Sequence, IteratorProtocol { private let file: UnsafeMutablePointer\u003cFILE\u003e init?(path: String) { guard let file = fopen(path, \"r\") else { return nil } self.file = file } public func next() -\u003e String? { var line: UnsafeMutablePointer\u003cCChar\u003e? = nil var linecap: Int = 0 defer { free(line) } return getline(\u0026line, \u0026linecap, file) \u003e 0 ? String(cString: line!) : nil } deinit { fclose(file) } public func makeIterator() -\u003e FileLines { return self } } // in new versions of Swift, this can be replaced with `if let lines = FileHandle(forReadingAtPath: pipe_in).bytes.lines` if let lines = FileLines(path: pipe_in) { for line in lines { print(line.uppercased(), terminator: \"\") } } else { print(\"Error reading from pipe: Could not open file at path \\(pipe_in)\") } "},"title":"streaming_pipe_in"},"/io_operations/streaming_pipe_in_and_out/":{"data":{"bash-3#Bash 3":"streaming_pipe_in_and_out.sh\n#!/bin/bash # Script reads text from a named pipe and writes it another named pipe, capitalized pipe_in=\"$1\" pipe_out=\"$2\" tr '[:lower:]' '[:upper:]' \u003c \"$pipe_in\" \u003e \"$pipe_out\" ","bash-5#Bash 5":"streaming_pipe_in_and_out.sh\n#!/bin/bash # Script reads text from a named pipe and writes it another named pipe, capitalized pipe_in=\"$1\" pipe_out=\"$2\" tr '[:lower:]' '[:upper:]' \u003c \"$pipe_in\" \u003e \"$pipe_out\" ","c#C#":"StreamingPipeInAndOut.cs\n//Script reads text from a named pipe and writes it another named pipe, capitalized using System; using System.IO; using System.IO.Pipes; class StreamingPipeInAndOut { public static void Main(string[] args) { string pipe_in = args[0]; string pipe_out = args[1]; using var input = new StreamReader(pipe_in); using var output = new StreamWriter(pipe_out) { AutoFlush = true }; string line; while ((line = input.ReadLine()) != null) { output.WriteLine(line.ToUpper()); } } } ","deno#Deno":"streaming_pipe_in_and_out.mjs\n//Script reads text from a named pipe and writes it another named pipe, capitalized import { readLines } from 'https://deno.land/std/io/mod.ts'; const [pipeInPath, pipeOutPath] = Deno.args; const input = await Deno.open(pipeInPath, { read: true }); const output = await Deno.open(pipeOutPath, { write: true }); const rl = readLines(input); for await (const line of readLines(input)) { await output.write(new TextEncoder().encode(line.toUpperCase() + '\\n')); } input.close(); output.close(); ","go#Go":"streaming_pipe_in_and_out.go\n// Script reads text from a named pipe and writes it to another pipe, capitalized package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { pipeIn := os.Args[1] pipeOut := os.Args[2] fileIn, _ := os.OpenFile(pipeIn, os.O_RDONLY, 0666) defer fileIn.Close() fileOut, _ := os.OpenFile(pipeOut, os.O_WRONLY, 0666) defer fileOut.Close() scanner := bufio.NewScanner(fileIn) for scanner.Scan() { if _, err := fileOut.WriteString(strings.ToUpper(scanner.Text()) + \"\\n\"); err != nil { fmt.Println(\"Error writing to output pipe:\", err) os.Exit(1) } } } ","java#Java":"StreamingPipeInAndOut.java\n// Script reads text from a named pipe and writes it another named pipe, capitalized import java.io.*; public class StreamingPipeInAndOut { public static void main (String[] args) throws IOException{ String pipe_in = args[0]; String pipe_out = args[1]; BufferedReader input = new BufferedReader(new FileReader(pipe_in)); BufferedWriter output = new BufferedWriter(new FileWriter(pipe_out)); String line; while ((line = input.readLine()) != null) { output.write(line.toUpperCase()); output.newLine(); // Ensure newline after each line output.flush(); // Flush to ensure immediate write } input.close(); output.close(); } } ","lua#Lua":"streaming_pipe_in_and_out.lua\n-- Script reads text from a named pipe and writes it another named pipe, capitalized local pipe_in = arg[1] local pipe_out = arg[2] local input_file = io.open(pipe_in, \"r\") local output_file = io.open(pipe_out, \"w\") for line in input_file:lines() do output_file:write(line:upper(), \"\\n\") output_file:flush() end input_file:close() output_file:close() ","nodejs#Nodejs":"streaming_pipe_in_and_out.mjs\n// Script reads text from a named pipe and writes it another named pipe, capitalized import * as fs from 'fs'; import * as readline from 'node:readline/promises'; const pipeIn = process.argv[2]; const pipeOut = process.argv[3]; const input = fs.createReadStream(pipeIn); const rl = readline.createInterface({ input }) const output = fs.createWriteStream(pipeOut); for await(const line of rl){ output.write(line.toUpperCase() + '\\n'); } ","perl#Perl":"streaming_pipe_in_and_out.pl\n# Script reads text from a named pipe and writes it another named pipe, capitalized use strict; use warnings; my ($pipe_in, $pipe_out) = @ARGV; open my $output, '\u003e', $pipe_out or die \"Cannot open output pipe: $!\"; open my $input, '\u003c', $pipe_in or die \"Cannot open input pipe: $!\"; $output-\u003eautoflush(1); while (my $line = \u003c$input\u003e) { print $output uc($line); } close $input; close $output; ","php#Php":"streaming_pipe_in_and_out.php\n\u003c?php //Script reads text from a named pipe and writes it another named pipe, capitalized $pipe_in = $argv[1]; $pipe_out = $argv[2]; $input_pipe = fopen($pipe_in, 'r'); $output_pipe = fopen($pipe_out, 'w'); while (($line = fgets($input_pipe)) !== false) { fwrite($output_pipe, strtoupper($line)); fflush($output_pipe); } fclose($input_pipe); fclose($output_pipe); ?\u003e ","python#Python":"streaming_pipe_in_and_out.py\n# Script reads text from a named pipe and writes it another named pipe, capitalized import sys pipe_in = sys.argv[1] pipe_out = sys.argv[2] with open(pipe_in, 'r', encoding='utf-8') as input_pipe: with open(pipe_out, 'w', encoding='utf-8') as output_pipe: for line in input_pipe: output_pipe.write(line.upper()) output_pipe.flush() ","r#R":"streaming_pipe_in_and_out.R\n# Script reads text from a named pipe and writes it another named pipe, capitalized args \u003c- commandArgs(trailingOnly = TRUE) pipe_in \u003c- args[1] pipe_out \u003c- args[2] input \u003c- file(pipe_in, \"r\") output \u003c- file(pipe_out, \"w\") while (length(line \u003c- readLines(input, n = 1)) \u003e 0) { writeLines(toupper(line), output) flush(output) } close(input) close(output) ","raku#Raku":"streaming_pipe_in_and_out.raku\n# Script reads text from a named pipe and writes it another named pipe, capitalized use v6; my ($pipe_in, $pipe_out) = @*ARGS; my $output = open($pipe_out, :w); my $input = open($pipe_in, :r); for $input.lines { $output.print(.uc ~ \"\\n\"); } ","ruby#Ruby":"streaming_pipe_in_and_out.rb\n# Script reads text from a named pipe and writes it another named pipe, capitalized pipe_in, pipe_out = ARGV File.open(pipe_out, 'w') do |output| output.sync = true File.open(pipe_in, 'r') do |input| input.each_line do |line| output.puts line.upcase end end end ","rust#Rust":"streaming_pipe_in_and_out.rs\n// Script reads text from a named pipe and writes it another named pipe, capitalized use std::env; use std::fs::File; use std::io::{BufRead, BufReader, BufWriter, Write}; fn main() { let args: Vec\u003cString\u003e = env::args().collect(); let pipe_in = \u0026args[1]; let pipe_out = \u0026args[2]; let reader = BufReader::new(File::open(pipe_in).unwrap()); let mut writer = BufWriter::new(File::create(pipe_out).unwrap()); for line in reader.lines() { writeln!(writer, \"{}\", line.unwrap().to_uppercase()).unwrap(); writer.flush().unwrap(); } } ","streaming_pipe_in_and_out#streaming_pipe_in_and_out":"streaming_pipe_in_and_outTest that named pipe can be read line by line and can write to output pipe without waiting for all lines to arrive","swift#Swift":"streaming_pipe_in_and_out.swift\n//Script reads text from a named pipe and writes it another named pipe, capitalized import Foundation #if os(macOS) || os(iOS) import Darwin #elseif os(Linux) import Glibc #endif setvbuf(stdout, nil, _IONBF, 0) let arguments = CommandLine.arguments let pipe_in = arguments[1] let pipe_out = arguments[2] let fileDescriptor = open(pipe_out, O_WRONLY) public class FileLines: Sequence, IteratorProtocol { private let file: UnsafeMutablePointer\u003cFILE\u003e init?(path: String) { guard let file = fopen(path, \"r\") else { return nil } self.file = file } public func next() -\u003e String? { var line: UnsafeMutablePointer\u003cCChar\u003e? = nil var linecap: Int = 0 defer { free(line) } return getline(\u0026line, \u0026linecap, file) \u003e 0 ? String(cString: line!) : nil } deinit { fclose(file) } public func makeIterator() -\u003e FileLines { return self } } // in new versions of Swift, this can be replaced with `if let lines = FileHandle(forReadingAtPath: pipe_in).bytes.lines` if let lines = FileLines(path: pipe_in) { for line in lines { write(fileDescriptor, line.uppercased(), line.uppercased().utf8.count) } } else { print(\"Error reading from pipe: Could not open file at path \\(pipe_in)\") } "},"title":"streaming_pipe_in_and_out"},"/io_operations/streaming_stdin/":{"data":{"bash-3#Bash 3":"streaming_stdin.sh\n#!/bin/bash # Script reads streaming input text and then prints capitalized string to stdout tr '[:lower:]' '[:upper:]' ","bash-5#Bash 5":"streaming_stdin.sh\n#!/bin/bash # Script reads streaming input text and then prints capitalized string to stdout tr '[:lower:]' '[:upper:]' ","c#C#":"StreamingStdin.cs\n// Script reads streaming input text and then prints capitalized string to stdout using System; class StreamingStdin{ public static void Main(string[] args){ string line; while (!string.IsNullOrEmpty(line = Console.ReadLine())){ Console.WriteLine(line.ToUpper()); } } } ","deno#Deno":"streaming_stdin.mjs\n// Script reads streaming input text and then prints capitalized string to stdout import { readLines } from 'https://deno.land/std/io/mod.ts'; const rl = readLines(Deno.stdin); for await (const line of rl) { console.log(line.toUpperCase()); } ","go#Go":"streaming_stdin.go\n// Script reads streaming input text and then prints capitalized string to stdout package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Println(strings.ToUpper(scanner.Text())) } } ","java#Java":"StreamingStdin.java\n// Script reads streaming input text and then prints capitalized string to stdout import java.util.Scanner; import java.util.stream.Stream; public class StreamingStdin { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); Stream.generate(scanner::nextLine) .takeWhile(line -\u003e !line.isEmpty()) // or other termination condition .map(String::toUpperCase) .forEach(System.out::println); scanner.close(); } } ","lua#Lua":"streaming_stdin.lua\n-- Lua script to read streaming input and print capitalized string to stdout -- Read all input lines and capitalize each line, then print for line in io.lines() do print(line:upper()) end ","nodejs#Nodejs":"streaming_stdin.mjs\n// Script reads streaming input text and then prints capitalized string to stdout import * as readline from 'node:readline/promises' const rl = readline.createInterface({ input: process.stdin }) for await (const line of rl) { console.log(line.toUpperCase()) } ","perl#Perl":"streaming_stdin.pl\nuse strict; use warnings; $| = 1; # Turn off output buffering print uc while \u003cSTDIN\u003e; ","php#Php":"streaming_stdin.php\n\u003c?php // Script reads streaming input text and then prints capitalized string to stdout while ($user_input = fgets(STDIN)) { echo strtoupper($user_input); } ","python#Python":"streaming_stdin.py\n\"\"\"Script reads streaming input text and then prints capitalized string to stdout\"\"\" while True: try: x = input() print(x.upper()) except EOFError: break ","r#R":"streaming_stdin.R\n#' Script to read input from stdin, line by line, transform, and write to stdout while(length(line \u003c- readLines(\"stdin\", n = 1L)) \u003e 0) { cat(toupper(line), fill = TRUE) } ","raku#Raku":"streaming_stdin.raku\n#Script reads streaming input text and then prints capitalized string to stdout use v6; for lines() { say .uc; $*OUT.flush; } ","ruby#Ruby":"streaming_stdin.rb\n# Script reads streaming input text and then prints capitalized string to stdout STDOUT.sync = true while input = gets puts input.upcase end ","rust#Rust":"streaming_stdin.rs\n// Script reads streaming input text and then prints capitalized string to stdout use std::io::{self, BufRead, Write}; fn main() { let mut stdout_handle = io::stdout().lock(); let stdin_handle = io::stdin().lock(); for line in stdin_handle.lines() { writeln!(stdout_handle, \"{}\", line.unwrap().to_uppercase()).unwrap(); stdout_handle.flush().unwrap(); } } ","streaming_stdin#streaming_stdin":"streaming_stdinTest that streaming stdin can be read line by line and can write to stdout without waiting for all lines to arrive","swift#Swift":"streaming_stdin.swift\n// Script reads streaming input text and then prints capitalized string to stdout // Turn off buffering for stdout #if os(macOS) || os(iOS) import Darwin #elseif os(Linux) import Glibc #endif setvbuf(stdout, nil, _IONBF, 0) import Foundation while let line = readLine(), !line.isEmpty { print(line.uppercased()) } "},"title":"streaming_stdin"},"/io_operations/write_file/":{"data":{"bash-3#Bash 3":"write_file.sh\n#!/bin/bash # Script to write text to a new file # Run script as `bash write_file.sh \u003coutput_file\u003e.txt 'some text'` outfile=\"$1\" text=\"$2\" if [ -z \"$outfile\" ] || [ -z \"$text\" ]; then echo \"Usage: $0 \u003coutput_file\u003e \u003ctext\u003e\" exit 1 fi echo -n \"$text\" | tr -d '\\n' | tr '[:lower:]' '[:upper:]' \u003e \"$outfile\" ","bash-5#Bash 5":"write_file.sh\n#!/bin/bash # Script to write text to a new file # Run script as `bash write_file.sh \u003coutput_file\u003e.txt 'some text'` outfile=\"$1\" text=\"$2\" if [ -z \"$outfile\" ] || [ -z \"$text\" ]; then echo \"Usage: $0 \u003coutput_file\u003e \u003ctext\u003e\" exit 1 fi echo -n \"${text^^}\" \u003e \"$outfile\" ","c#C#":"WriteFile.cs\n//Script to write text to a new file //Run script as `csharp write_file.cs \u003coutput_file\u003e.txt 'some text'` using System; using System.IO; class WriteFile { public static void Main(string[] args) { string outFile = args[0]; string text = args[1].ToUpper(); File.WriteAllText(outFile, text); } } ","deno#Deno":"write_file.mjs\n// Script to write text to a new file const [filename, ...textParts] = Deno.args; const text = textParts.join(' '); await Deno.writeTextFile(filename, text.toUpperCase()); ","go#Go":"write_file.go\n//Script to write text to a new file //Run script as `go write_file.go \u003coutput_file\u003e.txt 'some text'` package main import ( \"os\" \"strings\" ) func main() { outFile := os.Args[1] text := strings.ToUpper(os.Args[2]) _ = os.WriteFile(outFile, []byte(text), 0644) } ","java#Java":"WriteFile.java\n//Script to write text to a new file //Run script as `java write_file.java \u003coutput_file\u003e.txt 'some text'` import java.io.IOException; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Paths; public class WriteFile { public static void main(String[] args) throws IOException{ if (args.length != 2) { System.err.println(\"Usage: java WriteFile.java \u003coutput_file\u003e.txt 'some text'\"); System.exit(1); } String outFile = args[0]; String text = args[1].toUpperCase(); Files.write(Paths.get(outFile), text.getBytes(StandardCharsets.UTF_8)); } } ","lua#Lua":"write_file.lua\n-- Lua script to write text to a new file -- Run script as `lua write_file.lua \u003coutput_file\u003e.txt 'some text'` local outfile = arg[1] local text = arg[2] local fh = io.open(outfile, \"w\") fh:write(text:upper()) fh:close() ","nodejs#Nodejs":"write_file.mjs\n// Script to write text to a new file import fs from 'fs/promises' const [outfile, text] = process.argv.slice(2) // Get command-line arguments await fs.writeFile(outfile, text.toUpperCase()) ","perl#Perl":"write_file.pl\n# Script to write text to a new file # Run script as `perl write_file.pl \u003coutput_file\u003e.txt 'some text'` use strict; use warnings; my ($outfile, $text) = @ARGV; open my $fh, '\u003e', $outfile or die \"Cannot open $ARGV[0]: $!\"; print $fh uc $text; ","php#Php":"write_file.php\n\u003c?php // Write text to a new file // Get command-line arguments $outfile = $argv[1]; $text = $argv[2]; // Convert the text to uppercase $uppercaseText = strtoupper($text); // Write the uppercase text to the specified file file_put_contents($outfile, $uppercaseText); ","python#Python":"write_file.py\n\"\"\"Script to write text to a new file. Run script as `python write_file.py \u003coutput_file\u003e.py \"some text\"` \"\"\" import sys import os outfile = sys.argv[1] text = sys.argv[2] with open(outfile, 'w') as f: f.write(text.upper()) ","r#R":"write_file.R\n# 'Script to write text to a new file # Get the command-line arguments args \u003c- commandArgs(trailingOnly = TRUE) outfile \u003c- args[1] text \u003c- args[2] # Open the output file and write text in uppercase writeLines(toupper(text), outfile, sep=\"\") ","raku#Raku":"write_file.raku\n# Script to write text to a new file # Run script as `perl write_file.pl \u003coutput_file\u003e.txt 'some text'` use v6; my ($outfile, $text) = @*ARGS; my $fh = open $outfile, :w; $fh.print: $text.uc; $fh.close; ","ruby#Ruby":"write_file.rb\n# Script to write text to a new file # Run script as `ruby write_file.rb \u003coutput_file\u003e.txt 'some text'` outfile, text = ARGV File.write(outfile, text.upcase) ","rust#Rust":"write_file.rs\n//Script to write text to a new file //Run script as `cargo write_file.rs \u003coutput_file\u003e.txt 'some text'` use std::env; use std::fs::write; fn main() { let args: Vec\u003cString\u003e = env::args().collect(); let out_file = \u0026args[1]; let text = \u0026args[2].to_uppercase(); write(out_file, text).unwrap(); } ","swift#Swift":"write_file.swift\n/*Script to write text to a new file. Run script as `swift write_file.py \u003coutput_file\u003e.swift \"some text\"` */ import Foundation guard CommandLine.arguments.count == 3 else { print(\"Usage: swift script.swift \u003coutfile\u003e \u003ctext\u003e\") exit(1) } let outfile = CommandLine.arguments[1] let text = CommandLine.arguments[2] // atomically must be false when writing to named pipe try text.uppercased().write(toFile: outfile, atomically: false, encoding: .utf8) ","write_file#write_file":"write_fileTest that a script, given a path to a named pipe, can write to that named pipe"},"title":"write_file"}}